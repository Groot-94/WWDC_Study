> Classes Are Awesome

### Class의 특징
**Encapsulation**
: 관련된 데이터와 기능을 묶음 
**Access Control**
: 코드 내부와 외부를 구분하는 벽을 만들 수 있다 -> 불변성 유지
**Abstraction**
: 클래스를 이용해 소통의 창을 만들 수 있다
**Namespace**
: 소프트웨어가 성장하며 발생하는 충돌을 막아주는 네임스페이스 제공
**Expressive Syntax**
: 메서드 호출과 프로퍼티를 작성하고 연결할 수 있다, 서브스크립트 사용
**Extensibility**
: 클래스는 확장성을 위해 열려 있다
<br>

### Protocol
> **"Type Are Awesome"**
> => I can do all that wirh structs and enums

Swift에서 이름을 지정할 수 있는 타입은 모두 일급 시민으로 이런 모든 이점들을 이용할 수 있음

_그럼 클래스의 특별한 점은?_
<br>

#### 상속
> 슈퍼클래스에서 복잡한 논리로 실질적인 메소드를 정의 
- 상속을 통해 서브클래스는 이런 메서드를 무료로 사용
- 해당 작업을 오버라이드로 변경해서 사용할 수 있음
=> 어려운 논리를 재사용할 수 있으면서 동시에 유연성과 변형이 가능

봐! 클래스 이렇게 좋지?^^
=> NoNo

강력하긴 하지만 비용은?? 🤔 
<br><br>

### 클래스의 문제
#### 1. Implicit Sharing - 자동 공유
클래스는 참조 타입이기 때문에 명시적으로 데이터를 공유하게 됨

> 문제) A랑 B랑 한 데이터에 대해 얘기하다가 A가 홀연히 바꿔버리면 B는 이상한 데이터를 참조하게 됨

코드의 버그를 없애려고 값을 여기저기 복사하다가 너무 많은 복사본이 생기고 코드가 느려짐
-> 디스패치큐에서 뭔가 처리하고 스레드가 변경 가능한 상태를 공유하면서 갑자기 경쟁 조건이 발생
-> 불변성을 보호하기 위해 잠금(Lock)을 추가
-> lock은 코드를 느려지게 하고 교착 상태로 이어질 수 있음
-> 복잡성을 더하고 곧 버그 🤯

> Defensive Copying
> Ineffeciency
> Race Condition
> Locks
> More Ineffeciency
> Deadlock
> Bug!

Cocoa 문서에서도 반복하는 동안 mutable한 컬렉션을 수정하는 것을 경고함
-> 클래스의 mutable 상태를 Implicit Sharing하기 때문에

근데 그건 cocoa collection이고 swift는 안됨^^ 
왜? swift collection은 값 유형이라 반복하는 컬렉션과 수정하는 컬렉션이 구별됨
<br><br>

#### 2. Inheritance All Up In Your Business 

슈퍼 클래스 하나를 가질 때 여러 추상화를 모델링 하고 싶으면? 🤷
컬렉션이 될 수 있고 직렬화가 될 수 있나? -> 클래스라면 ❌

- 클래스는 단일 상속이라 관련된 모든 것이 함께 상속되면서 클래스가 점점 부풀려짐
- 또한 `확장할 때`가 아니라 `클래스를 정의하는 순간`에 슈퍼클래스를 선택해야 함 
- 슈퍼클래스에 저장 프로퍼티가 있으면 무조건 받아드려야 함 + 초기화도 해줘야 함
- 클래스를 작성할 때 final을 사용하지 않고, 메서드가 재정의될 가능성을 고려하지 않고, 메서드가 수행할 작업을 알고 있는 것처럼 코드를 작성해야 함 🤦


\~~~> (그래서 델리케이트 패턴을 사용하는 것)
<br><br>

#### 3. Lost Type Relationship 
어떤 역할을 하는 메서드가 있다고 하자. (예를 들어 정렬하기)


![](https://velog.velcdn.com/images/juyoung999/post/b5379c24-692b-4bd3-b918-d6aee7f6c252/image.png)

- 클래스로는 메서드가 하위 클래스에서 구현되지 않으면 실제로 할 수 있는 것은 없음
- 강제 다운캐스트 = 일부 중요한 형식 관계가 손실되었다는 신호 -> 추상화 클래스를 사용

추상화 매커니즘이 필요
=> 원치 않는 인스턴스 데이터나 관련 initialize 복잡성을 강요하지 않는 것
=> 재정의 항목에 모호성을 남기지 않기

➡️ 프로토콜은 이러한 이점을 모두 가짐 = Swift를 프로토콜 지향 프로그래밍 언어로 만든 이유

Swift는 객체 지행 프로그래밍에 적합하지만 중심에는 프로토콜 지향이 있음
<br><br>

---

### Class -> Protocol
![](https://velog.velcdn.com/images/juyoung999/post/b99d72c1-dd87-47d5-9c95-197cb3087e13/image.png)

- 메서드를 미리 정의하지 않아도 됨 -> 동적 런타임 검사를 정적 검사로 
- 구조체에도 적용 가능
- `Self`로 매개변수 타입을 자체 타입으로 제한할 수 있음
-> `other`이 `value`를 가진 것을 알 수 있어 타입 캐스팅이 필요하지 않음
<br>

### Self
![](https://velog.velcdn.com/images/juyoung999/post/6fe7bd6c-26eb-47a8-9363-16fec481fef2/image.png)

- 타입으로 사용할 수 없음
- 컬렉션은 이질적이지 않고 동질적으로 됨
- 인스턴스 간의 상호작용은 모든 모델 타입 간의 상호작용을 의미하지 않음
- 동적 다형성에서 정적 다형성으로 교환
- 컴파일러 최적화

----

#### 그래서 진짜 프로토콜이 클래스를 대체할 수 있을까?
- 이미 존재하는 타입을 extension해서 프로토콜을 준수하게 할 수 있음
- 프로토콜을 extension해서 즉시 충족되는 요구사항을 만들 수 있음 


#### 그럼 클래스는 언제 써?
- 암시적 공유를 원하는 경우 -> 참조 유형이 필요할 때
- 인스턴스 수명이 파일과 같은 외부 부작용과 관련된 경우
- 추상화 인스턴스가 "sink"인 경우 (ex. CGContext)
<br>

> #### ✏️ 요약 
> 1. 슈퍼클래스보다 훨씬 더 큰 프로토콜을
> 2. 프로토콜 확장



[Protocol oriented Programming](https://developer.apple.com/videos/play/wwdc2015/408/)
